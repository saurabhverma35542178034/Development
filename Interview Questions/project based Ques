1. What versioining tools you used?
 In my last project, we used Azure DevOps as our version control and project management platform. The repositories inside Azure DevOps are Git-based, so I worked with Git commands for branching, merging, and pull requests, but the code was hosted and managed through Azure Repos.



Explain your authentication flow.
    ðŸ‘‰ JWT with access + refresh token stored in HTTP-only cookie. Login â†’ Server generates tokens â†’ Refresh token issue new access token â†’ Logout clears cookies.

How you managed state in your project?
ðŸ‘‰ Context API + useReducer for small app, Redux for large app (tickets, users).

Error Handling in project?
ðŸ‘‰ Global error boundary + toast notifications on API failure.

How you optimized React performance?
ðŸ‘‰ Lazy loading, React.memo, code splitting, debouncing search.

How you structured your project?
ðŸ‘‰ src/components, src/pages, src/hooks, src/services(api calls), src/context.

How do you secure APIs in frontend?
ðŸ‘‰ HTTP-only cookies, CSRF tokens, rate limiting (backend support).

How do you handle roles & permissions?
ðŸ‘‰ Role stored in JWT payload, React routes protected based on role.

How you tested your frontend?
ðŸ‘‰ Unit tests with Jest/RTL, integration tests for forms, Postman for API.

How you deployed project?
ðŸ‘‰ Build React app â†’ host on Netlify/Vercel/AWS S3 + CloudFront. Backend on AWS EC2.

How do you track errors in production?
ðŸ‘‰ Sentry/New Relic integration + console error logging.